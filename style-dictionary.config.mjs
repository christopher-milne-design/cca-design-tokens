import StyleDictionary from 'style-dictionary';

// Custom formatter to generate a Tailwind theme extension
const tailwindFormatter = ({ dictionary }) => {
  const colors = {};
  const spacing = {};
  const fontSize = {};
  const fontWeight = {};
  const lineHeight = {};
  const borderRadius = {};

  dictionary.allTokens.forEach(token => {
    const path = token.path;
    
    if (path[0] === 'color') {
      if (!colors[path[1]]) colors[path[1]] = {};
      colors[path[1]][path[2]] = token.value;
    } else if (path[0] === 'spacing') {
      spacing[path[1]] = token.value;
    } else if (path[0] === 'fontSize') {
      fontSize[path[1]] = token.value;
    } else if (path[0] === 'fontWeight') {
      fontWeight[path[1]] = token.value;
    } else if (path[0] === 'lineHeight') {
      lineHeight[path[1]] = token.value;
    } else if (path[0] === 'borderRadius') {
      borderRadius[path[1]] = token.value;
    }
  });

  const theme = {
    colors,
    spacing,
    fontSize,
    fontWeight,
    lineHeight,
    borderRadius
  };

  // Remove empty objects
  Object.keys(theme).forEach(key => {
    if (Object.keys(theme[key]).length === 0) {
      delete theme[key];
    }
  });

  return `// This file is auto-generated by Style Dictionary
// Do not edit directly
export const tokens = ${JSON.stringify(theme, null, 2)};
`;
};

// Custom formatter to generate Tailwind CSS classes
const tailwindCSSFormatter = ({ dictionary }) => {
  const cssClasses = [];
  
  dictionary.allTokens.forEach(token => {
    const path = token.path;
    const value = token.value;
    
    if (path[0] === 'color') {
      const colorName = path[1];
      const shade = path[2];
      cssClasses.push(`  --color-${colorName}-${shade}: ${value};`);
    } else if (path[0] === 'spacing') {
      const spacingName = path[1];
      cssClasses.push(`  --spacing-${spacingName}: ${value};`);
    } else if (path[0] === 'fontSize') {
      const fontSizeName = path[1];
      cssClasses.push(`  --font-size-${fontSizeName}: ${value};`);
    } else if (path[0] === 'fontWeight') {
      const fontWeightName = path[1];
      cssClasses.push(`  --font-weight-${fontWeightName}: ${value};`);
    } else if (path[0] === 'lineHeight') {
      const lineHeightName = path[1];
      cssClasses.push(`  --line-height-${lineHeightName}: ${value};`);
    } else if (path[0] === 'borderRadius') {
      const borderRadiusName = path[1];
      cssClasses.push(`  --border-radius-${borderRadiusName}: ${value};`);
    }
  });

  return `/* This file is auto-generated by Style Dictionary */
/* Do not edit directly */

:root {
${cssClasses.join('\n')}
}

/* Tailwind utility classes */
${dictionary.allTokens.map(token => {
  const path = token.path;
  const value = token.value;
  
  if (path[0] === 'color') {
    const colorName = path[1];
    const shade = path[2];
    return `.text-${colorName}-${shade} { color: var(--color-${colorName}-${shade}); }`;
  } else if (path[0] === 'spacing') {
    const spacingName = path[1];
    return `.p-${spacingName} { padding: var(--spacing-${spacingName}); }`;
  } else if (path[0] === 'fontSize') {
    const fontSizeName = path[1];
    return `.text-${fontSizeName} { font-size: var(--font-size-${fontSizeName}); }`;
  } else if (path[0] === 'fontWeight') {
    const fontWeightName = path[1];
    return `.font-${fontWeightName} { font-weight: var(--font-weight-${fontWeightName}); }`;
  } else if (path[0] === 'lineHeight') {
    const lineHeightName = path[1];
    return `.leading-${lineHeightName} { line-height: var(--line-height-${lineHeightName}); }`;
  } else if (path[0] === 'borderRadius') {
    const borderRadiusName = path[1];
    return `.rounded-${borderRadiusName} { border-radius: var(--border-radius-${borderRadiusName}); }`;
  }
  return '';
}).filter(Boolean).join('\n')}
`;
};

// Register custom formatters
StyleDictionary.registerFormat({
  name: 'tailwind/theme',
  format: tailwindFormatter
});

StyleDictionary.registerFormat({
  name: 'tailwind/css',
  format: tailwindCSSFormatter
});

// Custom preprocessor to extract tokens from Token Studio format
const tokenStudioPreprocessor = (dictionary) => {
  const processed = { ...dictionary };
  
  // If tokens.json has Token Studio format ($themes, $metadata, token sets)
  if (dictionary.properties && dictionary.properties.$themes) {
    const tokenSets = Object.keys(dictionary.properties).filter(
      key => !key.startsWith('$')
    );
    
    // Extract tokens from the first token set (e.g., 'global')
    const firstSet = tokenSets[0];
    if (firstSet && dictionary.properties[firstSet]) {
      processed.properties = dictionary.properties[firstSet];
    }
  }
  
  return processed;
};

export default {
  // Support both Token Studio format (tokens.json) and individual files
  source: ['tokens.json', 'tokens/**/*.json'],
  preprocessors: ['tokens-studio'],
  platforms: {
    tailwind: {
      transformGroup: 'css',
      buildPath: 'lib/',
      files: [
        {
          destination: 'tokens.js',
          format: 'tailwind/theme'
        },
        {
          destination: 'tokens.css',
          format: 'tailwind/css'
        }
      ]
    }
  }
};
