import StyleDictionary from 'style-dictionary';

// Custom formatter to generate a Tailwind theme extension
const tailwindFormatter = ({ dictionary }) => {
  const colors = {};
  const spacing = {};
  const fontSize = {};
  const fontWeight = {};
  const lineHeight = {};
  const borderRadius = {};
  const semantic = { colors: {} };
  const typography = { desktop: {}, mobile: {} };

  dictionary.allTokens.forEach(token => {
    const path = token.path;
    
    if (path[0] === 'color') {
      if (!colors[path[1]]) colors[path[1]] = {};
      colors[path[1]][path[2]] = token.value;
    } else if (path[0] === 'semantic') {
      // Handle semantic tokens
      const category = path[1]; // brand, text, surface, feedback, border
      const tokenName = path.slice(2).join('-'); // primary, primary-hover, etc.
      if (!semantic.colors[category]) semantic.colors[category] = {};
      
      // Keep original reference if it exists, otherwise use resolved value
      const originalValue = token.original?.value || token.value;
      const value = typeof originalValue === 'string' && originalValue.includes('{')
        ? originalValue.replace(/\{color\.([^.]+)\.([^}]+)\}/g, 'var(--color-$1-$2)')
        : token.value;
      semantic.colors[category][tokenName] = value;
    } else if (path[0] === 'spacing') {
      spacing[path[1]] = token.value;
    } else if (path[0] === 'fontSize') {
      fontSize[path[1]] = token.value;
    } else if (path[0] === 'fontWeight') {
      fontWeight[path[1]] = token.value;
    } else if (path[0] === 'lineHeight') {
      lineHeight[path[1]] = token.value;
    } else if (path[0] === 'borderRadius') {
      borderRadius[path[1]] = token.value;
    } else if (path[0] === 'typography') {
      // Handle typography system: desktop/mobile → category → variant → property
      const breakpoint = path[1]; // desktop or mobile
      const category = path[2]; // headings, paragraphs, labels, buttons
      const variant = path[3]; // h1, p1, button-large, etc.
      const property = path[4]; // fontSize, lineHeight, letterSpacing, fontWeight
      
      if (!typography[breakpoint]) typography[breakpoint] = {};
      if (!typography[breakpoint][category]) typography[breakpoint][category] = {};
      if (!typography[breakpoint][category][variant]) typography[breakpoint][category][variant] = {};
      
      // Resolve fontWeight references
      let value = token.value;
      if (property === 'fontWeight' && typeof value === 'string' && value.includes('{')) {
        value = value.replace(/\{fontWeight\.([^}]+)\}/g, (match, weight) => {
          return fontWeight[weight] || match;
        });
      }
      
      typography[breakpoint][category][variant][property] = value;
    }
  });

  const theme = {
    colors,
    spacing,
    fontSize,
    fontWeight,
    lineHeight,
    borderRadius,
    semantic,
    typography
  };

  // Remove empty objects
  Object.keys(theme).forEach(key => {
    if (typeof theme[key] === 'object' && Object.keys(theme[key]).length === 0) {
      delete theme[key];
    }
  });

  return `// This file is auto-generated by Style Dictionary
// Do not edit directly
export const tokens = ${JSON.stringify(theme, null, 2)};
`;
};

// Custom formatter to generate Tailwind CSS classes
const tailwindCSSFormatter = ({ dictionary }) => {
  const cssClasses = [];
  
  dictionary.allTokens.forEach(token => {
    const path = token.path;
    const value = token.value;
    
    if (path[0] === 'color') {
      const colorName = path[1];
      const shade = path[2];
      cssClasses.push(`  --color-${colorName}-${shade}: ${value};`);
    } else if (path[0] === 'spacing') {
      const spacingName = path[1];
      cssClasses.push(`  --spacing-${spacingName}: ${value};`);
    } else if (path[0] === 'fontSize') {
      const fontSizeName = path[1];
      cssClasses.push(`  --font-size-${fontSizeName}: ${value};`);
    } else if (path[0] === 'fontWeight') {
      const fontWeightName = path[1];
      cssClasses.push(`  --font-weight-${fontWeightName}: ${value};`);
    } else if (path[0] === 'lineHeight') {
      const lineHeightName = path[1];
      cssClasses.push(`  --line-height-${lineHeightName}: ${value};`);
    } else if (path[0] === 'borderRadius') {
      const borderRadiusName = path[1];
      cssClasses.push(`  --border-radius-${borderRadiusName}: ${value};`);
    }
  });

  return `/* This file is auto-generated by Style Dictionary */
/* Do not edit directly */

:root {
${cssClasses.join('\n')}
}

/* Tailwind utility classes */
${dictionary.allTokens.map(token => {
  const path = token.path;
  const value = token.value;
  
  if (path[0] === 'color') {
    const colorName = path[1];
    const shade = path[2];
    return `.text-${colorName}-${shade} { color: var(--color-${colorName}-${shade}); }`;
  } else if (path[0] === 'spacing') {
    const spacingName = path[1];
    return `.p-${spacingName} { padding: var(--spacing-${spacingName}); }`;
  } else if (path[0] === 'fontSize') {
    const fontSizeName = path[1];
    return `.text-${fontSizeName} { font-size: var(--font-size-${fontSizeName}); }`;
  } else if (path[0] === 'fontWeight') {
    const fontWeightName = path[1];
    return `.font-${fontWeightName} { font-weight: var(--font-weight-${fontWeightName}); }`;
  } else if (path[0] === 'lineHeight') {
    const lineHeightName = path[1];
    return `.leading-${lineHeightName} { line-height: var(--line-height-${lineHeightName}); }`;
  } else if (path[0] === 'borderRadius') {
    const borderRadiusName = path[1];
    return `.rounded-${borderRadiusName} { border-radius: var(--border-radius-${borderRadiusName}); }`;
  }
  return '';
}).filter(Boolean).join('\n')}
`;
};

// Register custom formatters
StyleDictionary.registerFormat({
  name: 'tailwind/theme',
  format: tailwindFormatter
});

StyleDictionary.registerFormat({
  name: 'tailwind/css',
  format: tailwindCSSFormatter
});

export default {
  source: ['tokens/**/*.json'],
  platforms: {
    tailwind: {
      transformGroup: 'css',
      buildPath: 'lib/',
      files: [
        {
          destination: 'tokens.js',
          format: 'tailwind/theme'
        },
        {
          destination: 'tokens.css',
          format: 'tailwind/css'
        }
      ]
    }
  }
};
